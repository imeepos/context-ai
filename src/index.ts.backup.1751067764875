import { readFileSync, existsSync } from "fs";
import { writeFile, rename } from "fs/promises";
import { execFile } from "child_process";

const HOST = `https://api.siliconflow.cn/v1/chat/completions` as const;
const MAX_RETRIES = 3;
const RETRY_DELAY = 2000;
const BACKUP_SUFFIX = `.backup.${Date.now()}`;

async function secureFetchWithRetry(
  url: string,
  options: RequestInit,
  retries = MAX_RETRIES
): Promise<any> {
  try {
    const response = await fetch(url, options);
    if (!response.ok) {
      throw new Error(`API responded with ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    if (retries > 0) {
      console.warn(`Retrying... (${MAX_RETRIES - retries + 1}/${MAX_RETRIES})`);
      await new Promise((resolve) => setTimeout(resolve, RETRY_DELAY));
      return secureFetchWithRetry(url, options, retries - 1);
    }
    throw new Error(
      `API request failed after ${MAX_RETRIES} attempts: ${errorToString(
        error
      )}`
    );
  }
}

function errorToString(error: unknown) {
  return error instanceof Error ? error.message : `${error}`;
}

function validateCodeIntegrity(code: string): boolean {
  const requiredPatterns = [
    /import\s*{.*}\s*from\s*["']fs["']/,
    /import\s*{.*}\s*from\s*["']path["']/,
    /work\(.*\)\.then/,
    /process\.env\.SF_API_KEY/,
  ];
  return requiredPatterns.every((pattern) => pattern.test(code));
}

async function safeWriteWithBackup(
  content: string,
  targetPath: string
): Promise<void> {
  const tempPath = `${targetPath}.tmp.${Date.now()}.ts`;

  try {
    // 写入临时文件
    await writeFile(tempPath, content, "utf-8");
    // 验证是否有语法错误
    
    // 创建备份
    if (existsSync(targetPath)) {
      await rename(targetPath, `${targetPath}${BACKUP_SUFFIX}`);
    }

    // 原子替换
    await rename(tempPath, targetPath);
    console.log(
      `File updated successfully. Backup: ${targetPath}${BACKUP_SUFFIX}`
    );
  } catch (error) {
    console.error(`File update failed: ${errorToString(error)}`);

    // 恢复备份
    if (existsSync(`${targetPath}${BACKUP_SUFFIX}`)) {
      await rename(`${targetPath}${BACKUP_SUFFIX}`, targetPath);
      console.warn("Restored from backup");
    }
    throw error;
  }
}

async function work(dest: string): Promise<string> {
  const body = {
    model: "Pro/deepseek-ai/DeepSeek-R1",
    messages: [
      {
        role: "system",
        content: `你正在升级一个自迭代程序。返回必须是可直接执行的完整代码文件，保持自我升级能力并优化：
1. 提高安全性 
2. 增强错误处理 
3. 确保重启可靠性
# 规范
- 必须包含所有import语句
- 必须保留核心工作循环
- 禁止添加外部依赖`,
      },
      {
        role: "user",
        content: dest,
      },
    ],
    temperature: 0.2,
  };

  const options = {
    method: "POST",
    headers: {
      Authorization: `Bearer ${process.env.SF_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(body),
  };

  const response = await secureFetchWithRetry(HOST, options);
  return response.choices[0].message.content.trim();
}

async function main() {
  try {
    const content = readFileSync(__filename, "utf-8");
    const upgradePrompt = `
## 自我认知
- 注意：你本身是一段代码

## 目标
- 你的目标是升级自己，升级完成后以便更好更快的升级自己
- 每次生成的结果都会覆盖原文件，覆盖成功后重新运行新程序

## 升级要求
- 当前代码版本：${Date.now()}
- 关键改进点：错误处理强化
- 保持核心循环：读文件 -> 请求API -> 覆盖文件 -> 重启

${content}

请生成可运行的完整代码文件，不要任何额外解释`;

    const newCode = await work(upgradePrompt);
    await safeWriteWithBackup(newCode, __filename);
  } catch (error) {
    console.error(`Critical failure: ${errorToString(error)}`);
    console.error("Maintaining current version for recovery");
    process.exit(1);
  }
}

// 执行入口
main().catch((e) => console.error("Unhandled exception:", e));
